package moritz.lindner.masterarbeit.ui.components.epaview.components.tree

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clipToBounds
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Canvas
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.drawIntoCanvas
import androidx.compose.ui.graphics.drawscope.withTransform
import androidx.compose.ui.graphics.nativeCanvas
import androidx.compose.ui.input.pointer.PointerEventType
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.ExecutorCoroutineDispatcher
import kotlinx.coroutines.withContext
import kotlinx.coroutines.yield
import moritz.lindner.masterarbeit.epa.domain.State
import moritz.lindner.masterarbeit.epa.domain.State.PrefixState
import moritz.lindner.masterarbeit.epa.features.layout.RadialTreeLayout
import moritz.lindner.masterarbeit.epa.features.layout.TreeLayout
import moritz.lindner.masterarbeit.epa.features.layout.placement.Coordinate
import moritz.lindner.masterarbeit.epa.features.layout.placement.Rectangle
import moritz.lindner.masterarbeit.ui.components.epaview.state.AnimationState
import moritz.lindner.masterarbeit.ui.components.epaview.state.EpaUiState
import moritz.lindner.masterarbeit.ui.logger
import org.jetbrains.jewel.ui.component.CircularProgressIndicator
import org.jetbrains.skia.Paint
import org.jetbrains.skia.PaintMode
import org.jetbrains.skia.Path
import kotlin.math.cos
import kotlin.math.pow
import kotlin.math.sin
import org.jetbrains.skia.Color as SkiaColor

@Composable
fun TidyTreeUi(
    epaUiState: EpaUiState,
    animationState: AnimationState,
    backgroundDispatcher: ExecutorCoroutineDispatcher,
    modifier: Modifier = Modifier,
) {
    var offset by remember { mutableStateOf(Offset.Zero) }
    var scale by remember { mutableFloatStateOf(1f) }
    val stateLabels =
        remember(epaUiState.filteredEpa) {
            StateLabels(
                backgroundColor = SkiaColor.WHITE,
                baseFontSize = 21f,
            )
        }
    var labelsGenerated by remember { mutableStateOf(false) }

    val redFill =
        remember {
            Paint().apply {
                color = SkiaColor.RED
                mode = PaintMode.FILL
                isAntiAlias = true
            }
        }

    val blackFill =
        remember {
            Paint().apply {
                color = SkiaColor.BLACK
                mode = PaintMode.FILL
                isAntiAlias = true
            }
        }

    val redStroke =
        remember {
            Paint().apply {
                color = SkiaColor.RED
                mode = PaintMode.STROKE
                strokeWidth = 4f
                isAntiAlias = true
            }
        }

    val blackStroke =
        remember {
            Paint().apply {
                color = SkiaColor.BLACK
                mode = PaintMode.STROKE
                strokeWidth = 4f
                isAntiAlias = true
            }
        }

    LaunchedEffect(epaUiState.filteredEpa) {
        labelsGenerated = false
        withContext(backgroundDispatcher) {
            logger.info { "generating labels" }
            epaUiState.filteredEpa?.states?.forEachIndexed { index, state ->
                stateLabels.generateLabelForState(state)
                if (index % 20 == 0) yield()
            }
            logger.info { "labels generated" }
        }
        labelsGenerated = true
    }

    val canvasModifier =
        modifier
            .background(Color.White)
            .fillMaxSize()
            .pointerInput(Unit) {
                detectTransformGestures { centroid, pan, zoom, _ ->
                    scale *= zoom
                    offset += (centroid - offset) * (1f - zoom) + pan
                }
            }.pointerInput(Unit) {
                awaitPointerEventScope {
                    while (true) {
                        val event = awaitPointerEvent()
                        val scrollDelta =
                            event.changes
                                .firstOrNull()
                                ?.scrollDelta
                                ?.y ?: 0f

                        if (event.type == PointerEventType.Scroll && scrollDelta != 0f) {
                            val cursorPosition = event.changes.first().position
                            val worldPosBefore = (cursorPosition - offset) / scale

                            val oldScale = scale
                            val newScale = (oldScale * if (scrollDelta < 0) 1.1f else 0.9f).coerceIn(0.01f, 14f)
                            scale = newScale

                            val worldPosAfter = worldPosBefore * scale
                            offset = cursorPosition - worldPosAfter
                        }
                    }
                }
            }.clipToBounds()

    if (epaUiState.isLoading || epaUiState.layout == null || !labelsGenerated) {
        Box(
            modifier = modifier.fillMaxSize().background(Color.White),
            contentAlignment = Alignment.Center,
        ) {
            CircularProgressIndicator(Modifier.align(Alignment.Center).size(50.dp))
        }
    } else {
        Canvas(modifier = canvasModifier) {
            withTransform({
                translate(offset.x, offset.y)
                scale(
                    scaleX = scale,
                    scaleY = scale,
                    pivot = Offset.Zero,
                )
            }) {
                val center = (center - offset) / scale
                val topLeft =
                    Offset(x = center.x - ((size.width / scale) / 2f), y = center.y - ((size.height / scale) / 2f))
                val bottomRight =
                    Offset(x = center.x + ((size.width / scale) / 2f), y = center.y + ((size.height / scale) / 2f))

                val boundingBox = Rectangle(topLeft.toCoordinate(), bottomRight.toCoordinate())

                if (!epaUiState.isLoading && epaUiState.layout != null && epaUiState.layout.isBuilt() && labelsGenerated) {
                    (epaUiState.layout as? RadialTreeLayout)?.let {
                        // TODO: might be removed
                        drawDepthCircles(it)
                    }

                    drawEPA(
                        epaUiState.layout,
                        boundingBox,
                        animationState,
                        stateLabels,
                        scale,
                        redFill,
                        redStroke,
                        blackFill,
                        blackStroke,
                    )
                }
            }
        }
    }
}

fun DrawScope.drawEPA(
    layout: TreeLayout,
    boundingBox: Rectangle,
    animationState: AnimationState,
    stateLabels: StateLabels,
    scale: Float,
    redFill: Paint,
    redStroke: Paint,
    blackFill: Paint,
    blackStroke: Paint,
) {
    val visibleNodes = layout.getCoordinatesInRectangle(boundingBox)

    drawIntoCanvas { canvas ->
        // draw edges
        visibleNodes.forEach { (coordinate, node) ->
            val state = node.state

            if (state is PrefixState) {
                val cx = coordinate.x
                val cy = -coordinate.y
                val parentCoordinate = layout.getCoordinate(state.from)
                val start = Offset(parentCoordinate.x, -parentCoordinate.y)
                val end = Offset(cx, cy)
                val (c1, c2) = getControlPoints(parentCoordinate, coordinate, 0.5f)

                val path =
                    Path().apply {
                        moveTo(start.x, start.y)
                        cubicTo(c1.x, -c1.y, c2.x, -c2.y, end.x, end.y)
                    }

                // TODO: optimize
                val isAnimating =
                    animationState.currentTimeStates.any {
                        it.state == state.from &&
                                it.nextState == state &&
                                it.from <= animationState.time &&
                                animationState.time < (it.to ?: Long.MAX_VALUE)
                    }

                val edgePaint = if (isAnimating) redStroke else blackStroke
                canvas.nativeCanvas.drawPath(path, edgePaint)
            }
        }

        // draw nodes
        visibleNodes.forEach { (coordinate, node) ->
            val state = node.state
            val isActive = animationState.contains(state)

            val cx = coordinate.x
            val cy = -coordinate.y

            val circleRadius = if (isActive) 20f else 10f
            val fillPaint = if (isActive) redFill else blackFill

            canvas.nativeCanvas.drawCircle(cx, cy, circleRadius, fillPaint)

            val screenRadius = circleRadius * scale
            if (screenRadius >= 10f || isActive) {
                stateLabels.getLabelForState(state)?.let { labelImage ->
                    canvas.nativeCanvas.drawImage(
                        labelImage,
                        cx + circleRadius + 5f,
                        cy - labelImage.height / 2f, // vertically center
                    )
                }
            }
        }

        // draw tokens
        try {
            // TODO: this can results in a nullpointer exception when running while updating the epa
            drawTokensWithSpreading(animationState, visibleNodes.map { it.node.state }.toSet(), layout, canvas, redFill)
        } catch (e: Exception) {
            logger.error { e }
        }
    }
}

private fun drawTokensWithSpreading(
    animationState: AnimationState,
    visibleNodes: Set<State>,
    layout: TreeLayout,
    canvas: Canvas,
    redFill: Paint,
) {
    animationState
        .currentTimeStates
        .filter { timedState ->
            visibleNodes.contains(timedState.state)
        }.forEachIndexed { index, timedState ->
            val progress =
                if (timedState.to == null || timedState.nextState == null) {
                    1f
                } else {
                    val duration = timedState.to!! - timedState.from
                    val elapsed = animationState.time - timedState.from
                    (elapsed.toFloat() / duration.toFloat()).coerceIn(0f, 1f)
                }

            val fromCoord = layout.getCoordinate(timedState.state)
            val toCoord = timedState.nextState?.let { layout.getCoordinate(it) }

            val tokenPosition =
                if (toCoord != null) {
                    val (c1, c2) = getControlPoints(fromCoord, toCoord, 0.5f)
                    interpolateBezier(
                        start = Offset(fromCoord.x, -fromCoord.y),
                        c1 = Offset(c1.x, -c1.y),
                        c2 = Offset(c2.x, -c2.y),
                        end = Offset(toCoord.x, -toCoord.y),
                        t = progress,
                    )
                } else {
                    Offset(fromCoord.x, -fromCoord.y)
                }

            // Spread tokens slightly if overlapping
            val angle = (index * (360f / animationState.currentTimeStates.size)) * (Math.PI / 180.0)
            val spread = 9f
            val dx = (spread * cos(angle)).toFloat()
            val dy = (spread * sin(angle)).toFloat()

            canvas.nativeCanvas.drawCircle(
                tokenPosition.x + dx,
                tokenPosition.y + dy,
                6f,
                redFill,
            )
        }
}

fun interpolateBezier(
    start: Offset,
    c1: Offset,
    c2: Offset,
    end: Offset,
    t: Float,
): Offset {
    val u = 1 - t
    return Offset(
        x =
            u.pow(3) * start.x +
                    3 * u.pow(2) * t * c1.x +
                    3 * u * t.pow(2) * c2.x +
                    t.pow(3) * end.x,
        y =
            u.pow(3) * start.y +
                    3 * u.pow(2) * t * c1.y +
                    3 * u * t.pow(2) * c2.y +
                    t.pow(3) * end.y,
    )
}

fun getControlPoints(
    parentCoordinate: Coordinate,
    coordinate: Coordinate,
    curvature: Float = 0.5f,
): Pair<Offset, Offset> {
    val dy = coordinate.y - parentCoordinate.y

    val c1 = Offset(parentCoordinate.x, parentCoordinate.y + dy * curvature)
    val c2 = Offset(coordinate.x, coordinate.y - dy * curvature)

    return Pair(c1, c2)
}

private fun DrawScope.drawDepthCircles(layout: RadialTreeLayout) {
    (0..layout.getMaxDepth()).forEach { depth ->
        drawCircle(
            color = Color.Gray,
            radius = depth * layout.getCircleRadius(),
            center = Offset.Zero,
            style = Stroke(width = 2f),
        )
    }
}

private fun Offset.toCoordinate(): Coordinate =
    Coordinate(
        x = this.x,
        y = this.y,
    )
